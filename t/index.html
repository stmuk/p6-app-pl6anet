<html>
<head>
<meta charset="utf-8">
</head>
<body>
<a href="http://stevemynott.blogspot.com/feeds/posts/default">Steve Mynott</a> 
YAPC::NA 2015 is underway and many videos from the first day already on line including <br /><br /><h2 class="yt watch-title-container"><span class="watch-title " dir="ltr" id="eow-title" title="Patrick Michaud - &quot;A butterfly&#39;s view of Perl 6&quot;">Patrick Michaud - "A butterfly&#39;s view of Perl 6"&nbsp;</span></h2><div class="yt watch-title-container"><br /></div><div class="yt watch-title-container"><a href="https://www.youtube.com/watch?v=PNhofgKG1sc"><span class="watch-title " dir="ltr" id="eow-title" title="Patrick Michaud - &quot;A butterfly&#39;s view of Perl 6&quot;"></span></a><span class="watch-title " dir="ltr" id="eow-title" title="Patrick Michaud - &quot;A butterfly&#39;s view of Perl 6&quot;"><a href="https://www.youtube.com/watch?v=PNhofgKG1sc">https://www.youtube.com/watch?v=PNhofgKG1sc </a></span></div>
<a href="http://www.nntp.perl.org/rss/perl.perl6.announce.rdf">perl.perl6.announce</a> 
On behalf of the Parrot team, I&#x26;#39;m proud to announce Parrot 7.4.0, also known &#x3C;br/&#x3E;as &#x26;quot;Festive Amazon&#x26;quot;. Parrot (http://parrot.org/) is a virtual machine aimed &#x3C;br/&#x3E;at running all dynamic languages. &#x3C;br/&#x3E; &#x3C;br/&#x3E;Parrot 7.4.0 is available on Parrot&#x26;#39;s FTP site &#x3C;br/&#x3E;(ftp://ftp.parrot.org/pub/parrot/releases/devel/7.4.0/), or by following the &#x3C;br/&#x3E;download instructions at http://parrot.org/download. For those who would like &#x3C;br/&#x3E;to develop on Parrot, or help develop Parrot itself, we recommend using Git to &#x3C;br/&#x3E;retrieve the source code to get the latest and best Parrot code. &#x3C;br/&#x3E; &#x3C;br/&#x3E;Parrot 7.4.0 News: &#x3C;br/&#x3E; - Documentation &#x3C;br/&#x3E; + Many minor corrections &#x3C;br/&#x3E; - Community &#x3C;br/&#x3E; + Coverity scans to resume RSN. &#x3C;br/&#x3E; &#x3C;br/&#x3E; &#x3C;br/&#x3E;The SHA256 message digests for the downloadable tarballs are: &#x3C;br/&#x3E;b191da72e668c5bd97e1792a1b5d8fe66713819066f6a2f5eef2e9bc21d92968 parrot-7.4.0.tar.gz &#x3C;br/&#x3E;724868f94bf7d45ba5cda29b041b18fc7cbcd2fe5196455cc3882c2f99a84f4b parrot-7.4.0.tar.bz2 &#x3C;br/&#x3E; &#x3C;br/&#x3E;Many thanks to all our contributors for making this possible, and our sponsors &#x3C;br/&#x3E;for supporting this project. Our next scheduled release is at 16 Jun 2015. &#x3C;br/&#x3E; &#x3C;br/&#x3E;Enjoy! &#x3C;br/&#x3E; &#x3C;br/&#x3E;
<a href="http://rakudo.org/feed/">rakudo.org</a> 
<h2>A useful, usable, &#8220;early adopter&#8221; distribution of Perl 6</h2>
<p>On behalf of the Rakudo and Perl 6 development teams, I&#8217;m happy to announce the July 2015 release of &#8220;Rakudo Star&#8221;, a useful and usable distribution of Perl 6. The tarball for the July 2015 release is available from <a href="http://rakudo.org/downloads/star/">http://rakudo.org/downloads/star/</a>.</p>
<p>This Rakudo Star release comes with support for the MoarVM backend (all module tests pass on supported platforms).</p>
<p>In the Perl 6 world, we make a distinction between the language (&#8220;Perl 6&#8243;) and specific implementations of the language such as &#8220;Rakudo Perl&#8221;. This Star release includes <a href="https://github.com/rakudo/rakudo/blob/nom/docs/announce/2015.07.md">release 2015.07.2</a> of the <a href="http://github.com/rakudo/rakudo">Rakudo Perl 6 compiler</a>, version 2015.07 of <a href="http://moarvm.org/">MoarVM</a>, plus various modules, documentation, and other resources collected from the Perl 6 community.</p>
<p>Some of the new compiler features added to this release include:</p>
<ul>
<li>Cool.substr(-rw) and &substr(-rw) now also accept a Range</li>
<li>Added trait &#8220;is required&#8221; on class attributes</li>
<li>&?ROUTINE and &?BLOCK</li>
<li>&words implemented (to completement .words)</li>
<li>Numeric comparison ops (== > etc) for DateTimes</li>
<li>samewith() now also works in subs</li>
<li>Calling the .clone method with alternate values no longer changes original</li>
<li>.grep and &grep now consume multiple elements for many-param blocks</li>
<li>ENTER phaser now can be used as an r-value</li>
</ul>
<p>Notable changes in modules shipped with Rakudo Star:</p>
<ul>
<li>Bailador: Add links to documentation</li>
<li>DBIish: Use Postgres environment variables for test configuration</li>
<li>doc: More documentation, mostly for IO-related classes and methods</li>
</ul>
<p>There are some key features of Perl 6 that Rakudo Star does not yet handle appropriately, although they will appear in upcoming releases.  Some of the not-quite-there features include:</p>
<ul>
<li>advanced macros</li>
<li>non-blocking I/O (in progress)</li>
<li>much of Synopsis 9 and 11</li>
</ul>
<p>There is an online resource at <a href="http://perl6.org/compilers/features">http://perl6.org/compilers/features</a> that lists the known implemented and missing features of Rakudo&#8217;s backends and other Perl 6 implementations.</p>
<p>In many places we&#8217;ve tried to make Rakudo smart enough to inform the programmer that a given feature isn&#8217;t implemented, but there are many that we&#8217;ve missed. Bug reports about missing and broken features are welcomed at <a href="&#109;&#x61;&#105;&#108;&#116;&#111;:&#x72;&#97;&#x6B;&#x75;&#x64;&#111;&#98;&#117;&#103;&#64;&#112;&#101;&#x72;l&#x2E;o&#114;&#103;">&#x72;&#97;&#x6B;&#x75;&#x64;&#111;&#98;&#117;&#103;&#64;&#112;&#101;&#x72;l&#x2E;o&#114;&#103;</a>.</p>
<p>See <a href="http://perl6.org/">http://perl6.org/</a> for links to much more information about Perl 6, including documentation, example code, tutorials, reference materials, specification documents, and other supporting resources. A draft of a Perl 6 book is available as docs/UsingPerl6-draft.pdf in the release tarball.</p>
<p>The development team thanks all of the contributors and sponsors for making Rakudo Star possible. If you would like to contribute, see <a href="http://rakudo.org/how-to-help">http://rakudo.org/how-to-help</a>, ask on the <a href="&#x6D;&#x61;&#105;l&#x74;&#x6F;:&#x70;er&#108;&#54;&#45;&#x63;&#x6F;&#x6D;&#112;&#105;&#108;&#101;&#x72;&#64;&#112;&#x65;&#114;&#108;&#46;&#x6F;&#114;&#103;">&#x70;er&#108;&#54;&#45;&#x63;&#x6F;&#x6D;&#112;&#105;&#108;&#101;&#x72;&#64;&#112;&#x65;&#114;&#108;&#46;&#x6F;&#114;&#103;</a> mailing list, or join us on IRC #perl6 on freenode.</p>

<a href="http://blogs.perl.org/users/pawel_bbkr_pabian/atom.xml">Pawel bbkr Pabian</a> 
   
<a href="http://pmthium.com/feed/">Pmthium</a> 
<p>At <a href="https://fosdem.org/2015/">FOSDEM 2015</a>, Larry <a href="https://fosdem.org/2015/schedule/event/get_ready_to_party/">announced</a> that there will likely be a <a href="http://perl6.org/">Perl 6</a> release candidate in 2015, possibly around the September timeframe. What we&#8217;re aiming for is concurrent publication of a language specification that has been implemented and tested in at least one usable compilation environment &#8212; i.e., <a href="http://rakudo.org/">Rakudo Perl 6</a>.</p>
<p>So, for the rest of 2015, we can expect the Rakudo development team to be highly focused on doing only those things needed to prepare for the Perl 6 release later in the year. And, from previous planning and discussion, we know that there are three major areas that need work prior to release: the <a title="APW2014 and the Rakudo Great List Refactor" href="http://pmthium.com/2014/10/apw2014/">Great List Refactor</a> (GLR), Native Shaped Arrays (NSA), and Normalization Form Grapheme (NFG).</p>
<p>&#8230;which brings us to <a href="http://parrot.org/">Parrot</a>. Each of the above items is made significantly more complicated by Rakudo&#8217;s ongoing support for Parrot, either because Parrot lacks key features needed for implementation (NSA, NFG) or because a lot of special-case code is being used to maintain adequate performance (lists and GLR).</p>
<p>At present most of the current userbase has switched over to <a href="http://moarvm.com/">MoarVM</a> as the backend, for a multitude of reasons. And more importantly, there currently aren&#8217;t any Rakudo or NQP developers on hand that are eager to tackle these problems for Parrot.</p>
<p>In order to better focus our limited resources on the tasks needed for a Perl 6 language release later in the year, we&#8217;re expecting to suspend Rakudo&#8217;s support for the Parrot backend sometime shortly after the 2015.02 release.</p>
<p>Unfortunately the changes that need to be made, especially for the GLR, make it impractical to simply leave existing Parrot support in place and have it continue to work at a &#8220;degraded&#8221; level. Many of the underlying assumptions will be changing. It will instead be more effective to (re)build the new systems without Parrot support and then re-establish Parrot as if it is a new backend VM for Rakudo, following the techniques that were used to create JVM, MoarVM, and other backends for Rakudo.</p>
<p>NQP will continue to support Parrot as before; none of the Rakudo refactorings require any changes to NQP.</p>
<p>If there are people that want to work on refactoring Rakudo&#8217;s support for Parrot so that it&#8217;s more consistent with the other VMs, we can certainly point them in the right direction. For the GLR this will mainly consists of migrating parrot-specific code from Rakudo into NQP&#8217;s APIs. For the NSA and NFG work, it will involve developing a lot of new code and feature capabilities that Parrot doesn&#8217;t possess.</p>

<a href="http://perl6advent.wordpress.com/feed/">Perl 6 Advent Calendar</a> 
<p>There are all kinds of things I could&#8217;ve written about here, but none of them felt quite right.  So I decided to write a few wrongs instead.</p>
<p>This year I had the privilege of experiencing a triple retinal detachment.  Fortunately, they did two surgeries to correct this.  Unfortunately, despite the surgeries, I ended up with a blind spot in half my macula and a paralyzed iris, stuck halfway open.  Fortunately, this was all in my &#8220;bad&#8221; eye, so if I look out the right eye, meaning the wrong eye, things look a little wrong, but if I look out the right eye, meaning the left eye, things still look fine.  It&#8217;s all very confusing, unless you&#8217;re the one looking out the eyes in question, in which case everything is completely clear, except for the fuzzy bits.  From the outside, I just look a little crazy, but that&#8217;s nothing new.</p>
<p>Similarly, people inside the Perl 6 community have a different viewpoint from people outside the community.  We often fret about this &#8220;echo chamber&#8221; effect, but that&#8217;s a problem that will become self-correcting as Perl 6 comes into more widespread use.  But for now, it does induce a few distortions in outsiders&#8217; perceptions of our community.</p>
<p>One thing that has never been quite clear to folks outside the community is how our design process works.  To the people inside the community, it&#8217;s clear that the process works quite well, and that&#8217;s why Perl 6 just keeps getting better all the time.  Every month we make a new release that is more performant and closer to the ideal of Perl 6 as expressed in the design docs and spec tests, even as those design docs and spec tests continue to converge on an implementable and optimizable design.  The whirlpool methodology works.  Eventually.</p>
<p>But this whirlpool that we find so strangely attractive depends on a kind of feedback loop that many projects do not achieve, and I think that part of the problem is that these projects get trapped by an inadequate view of the nature of wrongness.  They see wrong wrong, as it were.  In contrast, we try to see wrong right.  Or at least righter.</p>
<p>And that&#8217;s really the first step, learning not to ask either/or questions.  Most design decisions are not binary, because most ideas are not completely right or wrong.  Instead, their degree of rightness is kinda truthy.  Which makes them righty or wrongy, I guess.  So the first step to figuring out right and wrong is to see how they are mixed together in various contexts.  And maybe we have an unfair advantage here.  This was a relatively easy principle for the Perl 6 community to learn, because as the original RFCs pointed out, Perl 5 is obviously a mixture of righty and wrongy ideas.  That&#8217;s why we decided to do Perl 6, after all.</p>
<p>Now, Santa Claus knows that most kids are really a mixture of naughty and nicey.  So the next step is to zoom out from ideas or features and also allow the people in your project to be a mixture of wrongy and righty, naughty and nicey.  Several decades ago people used to talk a lot about &#8220;egoless&#8221; programming, but that&#8217;s not really what we&#8217;re doing.  We all have our egos here, but somehow we&#8217;ve managed (mostly) to attach those egos to higher community ideals rather than to individual ideas or implementations.  This frees people to experiment.</p>
<p>The social contract, frequently expressed as &#8220;forgiveness > permission&#8221;, really means that you have permission to try things out that might turn out right, as long as the rest of us have permission to back them out again if they turn out to be not-so-right.  This operates on different scales, from small bug patches to complete attempts at implementation.  We don&#8217;t promise to use a particular idea or module or implementation, but we do promise to learn from it, and to learn why it is suboptimal if we don&#8217;t use it.</p>
<p>It seems our modern western culture always has to find someone to blame, and even in our community we don&#8217;t promise not to blame anyone if something goes haywire.  On the other hand, in our community, blame is merely a reason for considering someone human, and forgiving them.  It&#8217;s not a mechanism for determining pecking order.</p>
<p>So we argue a lot on our IRC channel, but many of us take great delight in arguing both sides of any issue.  Eventually we either reach a consensus, or decide we don&#8217;t know enough yet, so we&#8217;d better argue again later when we know more.  Occasionally I have to invoke rule #1, &#8220;Larry is always right&#8221;âbut not as often as you might think.  Note that we also have rule #2, &#8220;If Larry changes his mind, he&#8217;s still right&#8221;âwhich is about letting Larry make mistakes, because Larry knows his brain is a mixture of wrongy and righty too.</p>
<p>So in a sense, this entire Perl 6 process is just a large, complicated experiment that we expect to have mixed success with, because we know our own mental limitations.  And we hope this also gives us some empathy with our end users.</p>
<p>Once you&#8217;ve decided that mistakes are part of the creative process, you can pretty much view the entire evolution of Perl as a dialectic succession of mistakes and corrections.  The original Perl design was a mistake.  Letting Perl get typecast as a &#8220;CGI scripting language&#8221; in order to prototype the Web was a mistake.  Letting the community try to redesign Perl was a mistake, hence most of the RFCs were mistakes.  Or at least many of the proposed solutions in the RFCs were mistakes, and there was no coherence at all to ideas for fixing Perl 5.</p>
<p>The various attempts at implementation can be viewed as unsuccessful experiments.  The early implementors prohibited me from working on the implementation.  This may have been a mistake.  Nowadays the implementors allow me to work on the implementations, which is certainly a mistake. <code>:)</code></p>
<p>Another way things go wrong in a design is to pick the wrong principle for guidance.  Most of the design principles we derived from thinking about the RFCs can be easily be abused when taken to extremes.  And we&#8217;ve got lots of principles to pick from.</p>
<p>Just for the fun of it, this last year I finally went back through the 361 original RFCs and reread them to see how we did.  (Maybe that&#8217;s why my retina detached&#8230;)  What struck me was how many of Perl 6&#8217;s current design principles trace directly back to one or more of the RFCs.  Of course, many of these principles came from elsewhere, but we decided to apply them in the new design.  After I&#8217;d annotated my list of RFCs, I tried to give a talk on them, but there were just too many principles to talk about.  Here is a list of principle we&#8217;ve used in the design, in no particular order:</p>
<p>â Don&#8217;t just do the first thing that occurs to you.<br />
â YAGNI.  (You Ain&#8217;t Gonna Need It)<br />
â Self-clocking code produces better syntax error messages.<br />
â Band-aids won&#8217;t regrow your limbs.<br />
â Torment the implementors on behalf of the users.<br />
â One-pass parsing is darn near mandatory for an extensible, braided language.<br />
â Kill two birds with one stone.<br />
â Avoid lists of exceptions the user has to memorize.<br />
â Think ahead.  (You think that&#8217;s cute this year&#8230;)<br />
â Unifications can simplify things, sometimes at little cost.<br />
â There&#8217;s no reason for an error message to be LTA (Less Than Awesome).<br />
â Watch out for XY problems.<br />
â There are not enough sigils in ASCII to classify everything.  Choose wisely.<br />
â Choose the right default, the one that enhances readability when omitted.<br />
â Larry is not omniscient.<br />
â Stick with Perl&#8217;s operator-rich philosophy.<br />
â Discourage unrelated overloading of existing operators; define new ops instead.<br />
â Don&#8217;t buy that special tool you see on TV.<br />
â DIHWIDT.  (Doctor, it hurts when I do this&#8230;)<br />
â Hang things on the right pegâand if there isn&#8217;t one, install one.<br />
â If you&#8217;re gonna generalize, do it harder, but not too hard.<br />
â Pragmas are like vice grips: they&#8217;re the wrong tool for any job, but they&#8217;ll do any job.<br />
â Languages with Do-What-I-Mean autodeclarations too often Don&#8217;t-What-I-Mean.<br />
â People really get attached to their preferred methods of sloppy thinking.<br />
â Question authority, especially your own.<br />
â Avoid accidental genericity.  Intentional genericity is okay though.<br />
â Late binding sometimes causes your program to be late.<br />
â Major features should fix lots of things.<br />
â Grammatical categories can create a system of related precedence droppers.<br />
â If you&#8217;re going to reduce the power of a construct, maybe remove it instead.<br />
â Little languages (such as regexes) don&#8217;t have to violate one-pass parsing.<br />
â Replace weak features with stong ones that degenerate to the weak case.<br />
â Plan to know more someday.<br />
â Don&#8217;t multiply entities without reason.<br />
â Sometimes it&#8217;s worth making a feature pervasive, such as topicization.<br />
â Don&#8217;t reinvent OO poorly.<br />
â &#8220;Everything is an object&#8221; doesn&#8217;t mean it&#8217;s all method calls.<br />
â Operational definitions are often weaker than declarative definitions.<br />
â Even declarative definitions are implemented by operations at compile time.<br />
â There are always tradeoffs.<br />
â Good ideas go nowhere without a champion.<br />
â Don&#8217;t punish the innocent with the guilty.<br />
â Math just is.  Don&#8217;t make people declare it.<br />
â The identity is the most important part of the API; the right method on the wrong object is always wrong.<br />
â People are like sheep, and will wander out any open gate.<br />
â Save your money for power tools.<br />
â No battle plan survives first contact with the enemy, or the second, or the third&#8230;<br />
â The waterbed theory of complexity means if you push here, it goes up over there, unless there&#8217;s a leak.<br />
â Generalizing is often cheaper than specializing.<br />
â Bad features are sometimes not intrinsically bad, but just in the wrong context.<br />
â Introspection is nearly always a design smell.<br />
â You can&#8217;t be both eager and lazy simultaneously.  Duh.<br />
â Conserve your brackets.  ASCII has so few of them.<br />
â Encourage Unicode operators, yet provide ASCII workarounds.<br />
â Sometimes it&#8217;s worthwhile to provide more than one way to do it; sometimes one way is enough.<br />
â Fundamental unifications don&#8217;t have to hurt.  If they do, maybe you&#8217;re persecuting the user.<br />
â Easy things should be easy, and hard things should be possible (aka &#8220;Huffman coding&#8221;).<br />
â The degenerate case should make sense.<br />
â Remove artificial discontinuities (such as special-casing negative subscripts).<br />
â Sometimes it&#8217;s better to leave where you are and approach the design from a different direction.<br />
â Don&#8217;t plan to confuse things without a really good reason.<br />
â Allow last-ditch escape hatches such as BEGIN and EVAL, but try to take away all their use cases.<br />
â Premature failure (always throwing exceptions) is often a kind of premature optimization.<br />
â Sometimes you have to retarget your shallow principles to a deeper level.<br />
â Perl is not intended so much as a first language as it is a last language.<br />
â All generalizations are false, including this one.</p>
<p>Arguably it was also a mistake to adopt so many principles.  <code>:)</code></p>
<p>Despite all these mistakes, a bunch of stubbornly optimistic people keep working on Perl 6.  And somehow, after all the years of mistakes, we&#8217;ve managed to come out with something rather nice.</p>
<p>And now we&#8217;re talking about releasing Perl 6.0.0 &#8220;officially&#8221; sometime in 2015.  After all these years of refusing to name a date, maybe this is a big mistake.  On the other hand, maybe NOT announcing would be a mistake.</p>
<p>Either way, it doesn&#8217;t really matter, because there&#8217;s no stopping Perl 6 now.  After a few final tweaks, sometime in 2015 we&#8217;ll finally be at a point where we can just decide when to tag the next release as 6.0.0.beta.  And maybe we&#8217;ll keep it in beta until 2015-12-25 or so.</p>
<p>Of course, I could be wrong.</p>
<p>But what is certainly right is this: someday the Whos will start singing, all the Grinches of the world will be surprised, and perhaps a few of them will decide to be not quite so wrong.  And they will be welcomed to our song, because we really do believe in forgiveness.</p>
<p>It&#8217;s beginning to look a lot like Christmas.</p><br />  <a rel="nofollow" href="http://feeds.wordpress.com/1.0/gocomments/perl6advent.wordpress.com/2836/"><img alt="" border="0" src="http://feeds.wordpress.com/1.0/comments/perl6advent.wordpress.com/2836/" /></a> <img alt="" border="0" src="https://pixel.wp.com/b.gif?host=perl6advent.wordpress.com&#038;blog=10740073&#038;post=2836&#038;subd=perl6advent&#038;ref=&#038;feed=1" width="1" height="1" />
<a href="http://brrt-to-the-future.blogspot.com/feeds/posts/default">brrt to the future</a> 
This week I made progress on the central &#39;tiling&#39; algorithm used for code generation. I think it makes an interesting story and theory, so I will try to explain it in this post. Unfortunately, I don&#39;t think I can explain it very well without resorting to computer-science jargon, but I hope you can forgive me.<br /><br /><b>What is tiling?</b><br /><i>Tiling</i> refers to the process of breaking an input tree into many pieces. The <i>tree</i> refers to the data structures representing the code that the JIT should compile. As I wrote a few weeks back, these trees are ultimately generated from templates, mapped to the MoarVM opcodes. Let&#39;s suppose we have a tree for the expression: <code>result = LOCAL[8] + 12</code> and that it&#39;d look like the code below:<br /><pre><code><br />(add <br /> (load<br /> (addr<br /> (local)<br /> 8)<br /> int_sz)<br /> (const<br /> 8<br /> int_sz))<br /></code></pre><br />I realize most people probably are not familiar with the syntax used here. These are called s-expressions, and there is fortunately little to know: &#39;(&#39; opens a list, &#39;)&#39; closes a list, and words represent symbols that are reproduced verbatim (as are the numbers). If we act like the first word in the list reperesents the name of a function and the rest of the list the arguments, it hopefully becomes clear how the text represents the expression (and you can add LISP to your linkedin profile at the same time).<br /><br />For those who prefer a visual layout (which is most people, I guess), the following graph represents the exact same code:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td><a href="http://2.bp.blogspot.com/-lyQeOtGkgJU/VbigxtP99zI/AAAAAAAAAPw/bXkgLivqHBY/s1600/code.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://2.bp.blogspot.com/-lyQeOtGkgJU/VbigxtP99zI/AAAAAAAAAPw/bXkgLivqHBY/s320/code.png" width="213" /></a></td></tr><tr><td class="tr-caption" style="font-size: 12.8000001907349px;">The code fragment under consideration.</td></tr></tbody></table><br />Tiling is necessary because there are many ways to implement this expression in machine code. For instance, every node can be mapped to a single instruction, as in the naive code below. Compare this to the improved code, which is only two instructions long: <br /><table><tbody><tr><th>Tree</th><th>Naive code</th><th>Improved Code</th></tr><tr><td><pre><code>(<span style="color: #bf9000;">add</span> <br /> (<span style="color: #990000;">load</span><br /> (<span style="color: #0b5394;">addr</span><br /> (<span style="color: #38761d;">local</span>)<br /> <span style="color: #0b5394;">8</span>)<br /> <span style="color: #990000;">int_sz</span>)<br /> (<span style="color: #741b47;">const<br /> 12<br /> int_sz</span>))<br /></code></pre></td><td><pre><code><span style="color: #351c75;">mov r0, 12</span><br /><span style="color: #0b5394;">lea r1, [<span style="color: #38761d;">rbx</span>+8]</span><br /><span style="color: #990000;">mov r2, [r1]</span><span style="color: #bf9000;"><br />mov r3, r0<br />add r3, r2</span><br /></code></pre></td><td><pre><code><span style="color: #990000;">mov r0,</span> <span style="color: #0b5394;">[<span style="color: #38761d;">rbx</span>+8]</span><br /><span style="color: #bf9000;">add r0</span>, <span style="color: #741b47;">12</span><br /></code></pre></td></tr></tbody></table><br /><br />As you can hopefully see from the color, in the improved code each instruction refers to multiple parts of the tree. As a result, the improved code is much shorter, and probably faster to execute.<br /><b>How do we do it?</b><br />There are two basic abstractions in tiling. &nbsp;The first of these is the <i>tile grammar</i>. A very simple grammar is shown below. Each of these <i>tile rules</i> maps a <i><span style="color: #38761d;">tree fragment</span></i> to an <span style="color: #990000;"><i>action</i></span>, at <span style="color: #0b5394;"><i>terminal</i></span> and a cost. A tile rule that matches a tree fragment conceptually replaces the fragment with it&#39;s terminal; the resulting terminal can be used to match other tiles.<br /><br /><pre><code>1: (tile: <span style="color: #990000;">local</span> (<span style="color: #38761d;">local</span>) <span style="color: #0b5394;">reg</span> 1)<br />2: (tile: <span style="color: #990000;">addr_reg</span> (<span style="color: #38761d;">addr</span> reg) <span style="color: #0b5394;">mem</span> 1)<br />3: (tile: <span style="color: #990000;">addr_mem</span> (<span style="color: #38761d;">addr</span> reg) <span style="color: #0b5394;">reg</span> 2)<br />4: (tile: <span style="color: #990000;">const</span> (<span style="color: #38761d;">const</span>) <span style="color: #0b5394;">reg</span> 2)<br />5: (tile: <span style="color: #990000;">load_reg</span> (<span style="color: #38761d;">load</span> reg) <span style="color: #0b5394;">reg</span> 5)<br />6: (tile: <span style="color: #990000;">load_mem</span> (<span style="color: #38761d;">load</span> mem) <span style="color: #0b5394;">reg</span> 5)<br />7: (tile: <span style="color: #990000;">add_reg</span> (<span style="color: #38761d;">add</span> reg reg) <span style="color: #0b5394;">reg</span> 2)<br />8: (tile: <span style="color: #990000;">add_cnst</span> (<span style="color: #38761d;">add</span> reg (const)) <span style="color: #0b5394;">reg</span> 3)<br />9: (tile: <span style="color: #990000;">add_ldrg</span> (<span style="color: #38761d;">add</span> reg (load reg)) <span style="color: #0b5394;">reg</span> 6)<br />10: (tile: <span style="color: #990000;">add_ldmm</span> (<span style="color: #38761d;">add</span> reg (load mem)) <span style="color: #0b5394;">reg</span> 6)<br /></code></pre><br />The second abstraction is the <i>rule set. </i>A given tree node can potentially be matched by any number of rules. For instance, <code>(const)</code> may be matched by rule 4 or it may be matched as the &#39;subrule&#39; of rule 8. (We denote the subrule of rule 8 as rule 8<sup>a</sup>). In fact, there is no way the matcher can distinguish between these two options when it evaluates the <code>(const)</code> node. The matcher can only distinguish between the two options when evaluating the parent node of const. (Parents often know more than their children). Hence, mapping a node often yields multiple rules.<br /><br />This is something of a challenge for matching the parent node. In case of the <code>(load)</code> node in the graph above, do we match to rule 6 <code>(load mem)</code> or rule 5 <code>(load reg)</code>? The <code>(addr)</code> node can map to either a <code>reg</code> or a <code>mem</code> terminal, so it does not reduce the ambiguity. The answer is that rather than trying to cut through the ambiguity we should embrace it. That is to say, we represent the combination of rules as a single <i>ruleset</i>, and the ruleset represent all possible matching rules.<br /><br />For example, in the grammar above, a <code>(const)</code> node by itself always matches to rule 4 or rule 8<sup>a</sup>. So the <code>(const)</code> matches a single ruleset consisting of <i>{ 4, 8<sup>a</sup> }</i>. Similarily, an <code>(addr)</code> always takes a <i>reg</i> terminal and maps to both rules <i>{ 2, 3 }</i>. In constrast, the <code>(load)</code> node can match rule 5 - if it&#39;s child matches to a <i>reg</i> terminal - or rule 6 if it&#39;s child matches to a <i>mem</i> terminal. (It can also match to rule 9<sup>a</sup> and 10<sup>a</sup>, but ignore that for simplicity). Since all nodes that generate a <i>mem</i> terminal (i.e. the <code>(addr)</code>) can also generate a <i>reg terminal</i>, rule 6 is always combined with rule 5, but the inverse is not the case. (It&#39;s perfectly possible to <code>(load)</code> the result of an <code>(add)</code> operation, for example). Thus, <code>(load)</code> maps to two distinct rulesets: <i>{ 5 }</i> and <i>{ 5, 6 }</i>.<br /><br /><b>Table generation</b><br />It is pretty easy to determine whether a rule will match a node and a combination of rulesets: just try if any of those rulesets can generate the required terminals. Checking this for all rules available will then give you a new combination of rules, which is also represented with a ruleset.&nbsp; Better yet, knowing the costs associated with each rule, one can determine the optimal rule to compute a node to the terminal required. For instance, in the tree above:<br /><ol><li><code>(local)</code> can only be matched by rule 1 (ruleset <i>{1}</i>).</li><li><code>(addr <i>{1}</i>)</code> can be matched by rule 2 and 3 equally. (ruleset <i>{2,3}</i>)</li><li><code>(load <i>{2,3}</i>)</code> can be matched by rule 5, 6, 9<sup>a</sup> and 10<sup>a</sup>, because the ruleset <i>{2,3}</i> from <code>(addr)</code> generates both <i>mem</i> and <i>reg</i> terminals. (ruleset <i>{5,6,9<sup>a</sup>,10<sup>a</sup>}</i>).</li><li><code>(const)</code> can be matched by rule 4 and 8<sup>a</sup> (ruleset: <i>{4, 8<sup>a</sup>}</i>).</li><li><code>(add)</code> can be matched by rule 7 and 8, because ruleset <i>{5,6,9<sup>a</sup>,10<sup>a</sup>}</i> can generate a <i>reg</i>, and ruleset <i>{4, 8<sup>a</sup>}</i> can generate the <code>(const)</code> placeholder expected by rule 8. Hence <code>(add <i>{5,6,9<sup>a</sup>, 10<sup>a</sup></i>} <i>{4, 8<sup>a</sup>})</i></code> yields ruleset <i>{7,8}</i>.</li></ol>Now to determine the optimum code:<br /><ol><li><code>(add)</code> can best be represented by rule 8, because this has lower cost than the combination of rule 4 and rule 7.</li><li><code>(load)</code> can best be represented by rule 6, because this has lower cost than rule 3 and 5 combined.</li><li><code>(const)</code> requires no specific representation being embedded in rule 8.</li><li>The same goes for <code>(addr)</code> and <code>(local)</code>.</li></ol>In fact, you can compute this information prior to the actual compilation process, and stick it in a table - simply by applying all rules to all combinations of rulesets. Doing this transforms the ambiguous, nondeterministic matching process into a deterministic table lookup. In CS jargon, it transforms the <i>NFA</i> represented by the tile grammar into a <i>DFA.</i> As in all such transformations, this takes up significant amounts of space.<br /><br /><b>Let&#39;s keep it simple</b><br />So much space, in fact, that we&#39;re not home and dry just yet. A table mapping the combination of a node and two children - indexed by ruleset - must be at least <i>O(n<sub>child</sub> Ã n<sup>2</sup><sub>ruleset</sub>)</i> large. If we naively generate all combinations of rules that start with a given head node we generate 2<sup>n</sup> rulesets per type of head. Some heads are potentially involved with over 10 rules (consider <code>(load)</code>, which is allowed in nearly all x86 instructions), giving - naively - 1024 rulesets. Most of these rulesets are impossible to generate. For example, in our miniature grammar, a ruleset containing <i>{8,9} </i>clearly cannot be generated. It is therefore in our keen interest to generate the minimum amount of rulesets.<br /><br />But that is pretty complicated: it either requires rather sensitive analysis of the grammar, which isn&#39;t algorithmicly cheap by itself; or we can simply read all the rulesets that can be generated from the grammar, by constructing the table that generates them. Clearly that is a chicken-and-egg problem: to find the rulesets that can be generated by a grammar, we have to make a table based on just those rulesets. Fortunately, chicken-and-egg problems can usually be solved by using some form of <a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank">topological sorting</a>. To put it in other words, we don&#39;t need to have <i>all</i> rulesets available to find the combination of rules the grammar can produce, <i>just some that generate all the terminals needed by a given node</i>. In our grammar above, we can just start by generating all rules for <code>(const)</code> and <code>(local)</code>, noting that they generate one ruleset each. After that is done, we can generate all rules that rely only on <i>reg</i>, which is the <code>(addr)</code> rule (generating <i>mem</i>). We continue process this until all rulesets have been generated. This dramatically reduces the size of the table, which is still pretty large. Without this procedure however, the time taken to build the table tends to explode on relatively small grammars.<br /><br />Ultimately the tiler table must be available for the JIT compiler, which is written in C. The tile table generator is written in perl5 (just like the expression template compiler), because, manipulexity and whipuptitude, and it runs everywhere, you know? In fact, perl5 is already a requirement for building MoarVM, which means I wouldn&#39;t introduce new build-time dependencies. (Nobody likes installing a build-time dependency, least of all me). Perl5 natively supports hash tables; C does not. So I chose to represent the table as a sorted array of key + value and use binary search to find the right items. There are certainly more efficient representations, but this is very simple and still guarantees quite adequate lookup times. This is important in ensuring the JIT compiler won&#39;t become a bottleneck itself.<br /><br />So that is the story of how I wrote the tiler table generator (and incidentally, a story how perl saved the day). With these in place, I can implement the final tiler quite trivially (I already did, again, in perl). I conclude with noting that while the Aho algorithm guarantees optimal tiling (within the limitations of the grammar), it is not an optimization method by itself. For truly good code - say, like GCC or LLVM can produce - much more is needed: instruction scheduling, register allocation, and true optimisation techniques. Until my next report, I&#39;ll be working on these topics. See you then!<br /><ol></ol>
<a href="https://6guts.wordpress.com/feed/">6guts</a> 
<p>This report covers the week starting the 20th July &#8211; which turned out to be the week I had to finish preparing course material and labs for one of Edument&#8217;s new courses. That managed to swallow most of the week, so only a handful of Perl 6 things got done. Happily, August is free of any teaching and authoring responsibilities, and will be dominated with Perl 6 work.</p>
<h3>Digging into multi-dimensional arrays in Perl 6</h3>
<p>I started a Rakudo branch to work on the multi-dimensional array support, and made various decisions about how things will work. I got some way into the changes to Array itself (and had it basically working provided you worked in terms of the *-POS API directly), and started to look at the ways the slicing implementation will need to change to pass multiple dimensions along (so you&#8217;ll actually be able to do the access with [&#8230;] as you&#8217;d expect).</p>
<h3>Banning confusion</h3>
<p>I took on one of the oldest RTs in the queue, which wished for there to be a compile time error on:</p>
<pre>say $*a; my $*a;</pre>
<p>There&#8217;s long been one on:</p>
<pre>say $a; my $a;</pre>
<p>Basically, it catches use-before-declaration confusion (since the declaration happens at compile time). The second case is clear cut; the first is less so as it involves a dynamically scoped variable and so we&#8217;re naturally a bit looser about those. But after a little discussion, Larry said he&#8217;d like to outlaw the first just like the second if it wasn&#8217;t too hard to implement. I took a look at the code, decided it wasn&#8217;t too bad at all, and fixed it.</p>
<h3>Unblocking the release</h3>
<p>During the preparation for the 2015.07 release, somebody noticed a regression in reporting &#8220;return outside of routine&#8221; errors, that the tests had missed. I jumped in to get it fixed up, and added a better test so we don&#8217;t bust it again.</p>
<h3>This week&#8217;s token regex engine patches</h3>
<p>I fixed RT #125648 (no syntax error for /00:11:22/), as well as looking into RT #77524 (Rakudo treated /a:/ as legal syntax and STD did not; it turns out Rakudo was right on this one).</p>
<h3>Other bits</h3>
<ul>
<li>Fix RT #125642 and RT #121308 (traits expecting types didn&#8217;t report bad type or make suggestions)</li>
<li>Analyze RT #125634 and get it down to a much smaller example of what&#8217;s wrong; no fix yet</li>
</ul><br />  <a rel="nofollow" href="http://feeds.wordpress.com/1.0/gocomments/6guts.wordpress.com/368/"><img alt="" border="0" src="http://feeds.wordpress.com/1.0/comments/6guts.wordpress.com/368/" /></a> <img alt="" border="0" src="https://pixel.wp.com/b.gif?host=6guts.wordpress.com&#038;blog=14597269&#038;post=368&#038;subd=6guts&#038;ref=&#038;feed=1" width="1" height="1" />
<a href="http://perlgeek.de/blog-en/perl-6/index.rss">Perlgeek.de</a> 
<!-- 1430038759 --> <p>This year, most of my contributions to <a href="http://perl6.org/">Perl 6</a> have been to <a href="http://doc.perl6.org/">the documentation</a>, or were directly inspired by writing the documentation.</p> <p>Quite often when I write documentation, I start thinking things like <em>this is a bit awkward to explain, wouldn't it be more consistent if ...</em> or <em>what happens when I use a negative number here? The implementation disallows it, but does it actually need to?</em> or <a href="https://github.com/rakudo/rakudo/commit/e9a972437d8d94d5be7d2c6a9080a978051b4da1"><em>if I tell people to just pass this particular value most of the time, why not make it the default?</em></a>.</p> <p>Like most people who aspires to be a good programmer, <a href="http://threevirtues.com/">I'm lazy</a>. In particular, I hate doing pointless work. And documenting inconsistencies or missing default values or arbitrary restrictions definitively feels like doing work that shouldn't be necessary. So with a sigh I overcome my laziness, and try to fix stuff in the code, the tests, and sometimes the design docs so I can be more lazy in documenting the features. And of course, to make the overall experience more pleasant for the end user.</p> <p>I've been skeptical of <a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">README-driven development</a> in the past, dismissing it as part of the outdated (or at least for software not suitable) <a href="http://en.wikipedia.org/wiki/Waterfall_model">waterfall model</a>, or as "no plan survives contact with the enemy". But now that I'm writing more docs, I see the value of writing docs early (of course with the provision that if things turn out to be impractical a documented, the docs may still be revised). Because it's very easy as a developer to lose the user's perspective, and writing docs makes it easier (at least for me) to look at the project from that perspective again.</p> <h3>Examples</h3> <p>With the philosophy part done, I'd like to bring some examples.</p> <h4>The missing default value</h4> <p>In Perl 6 land, we distinguish meta classes, which control behavior of a type, and representations, which control memory layout of objects.</p> <p>Most Perl 6 objects have the representation <code>P6opaque</code>, which provides opaque, efficient storage for objects with attributes, properties, slots, or however you call per-object storage in your favorite language. Special representations exists for interfacing with C libraries, concurrency control and so on.</p> <p>The class <a href="http://doc.perl6.org/type/Metamodel::Primitives">Metamodel::Primitives</a> provides primitives for writing meta classes, with this method: <pre> <span class="synStatement">method</span> create_type(Mu <span class="synIdentifier">$how</span><span class="synStatement">,</span> <span class="synIdentifier">$repr</span>) { <span class="synStatement">...</span> } </pre> <p><code>$how</code> is our standard name for Meta stuff (from "Higher Order Workings", or simply from controlling <em>how</em> stuff works), and <code>$repr</code> is the name of the representation.</p> <p>Somebody new to meta object stuff doesn't need to know much about representations (except when they want to very low-level stuff), so the docs for <code>create_type</code> could have said <em>if you don't know what representation to use, use <code>P6opaque</code></em>. Or I could just establish <code>P6opaque</code> as a default:</p> <pre> <span class="synStatement">method</span> create_type(Mu <span class="synIdentifier">$how</span><span class="synStatement">,</span> <span class="synIdentifier">$repr</span> <span class="synStatement">=</span> <span class="synSpecial">'</span><span class="synConstant">P6opaque</span><span class="synSpecial">'</span>) { <span class="synStatement">...</span> } </pre> <p>There, less to document, and somebody new to this stuff can ignore the whole representations business for a while longer.</p> <h4>Arbitrary restrictions</h4> <p>The method <code>rotor</code> on the <a href="http://doc.perl6.org/type/List">List</a> was intended to create a list of sublists with fixed number of elements from the original list, potentially with overlap. So the old API was:</p> <pre> <span class="synStatement">method</span> rotor(<span class="synIdentifier">$elems</span> <span class="synStatement">=</span> <span class="synConstant">2</span><span class="synStatement">,</span> <span class="synIdentifier">$overlap</span> <span class="synStatement">=</span> <span class="synConstant">1</span>) { <span class="synStatement">...</span> } </pre> <p>And one would use it a</p> <pre> <span class="synStatement">.</span><span class="synIdentifier">say</span> <span class="synStatement">for</span> (<span class="synConstant">1</span><span class="synStatement">..</span><span class="synConstant">7</span>)<span class="synStatement">.</span>rotor(<span class="synConstant">3</span><span class="synStatement">,</span> <span class="synConstant">1</span>)<span class="synStatement">;</span> <span class="synComment"># 1 2 3</span> <span class="synComment"># 3 4 5</span> <span class="synComment"># 5 6 7</span> </pre> <p>Again I had an issue with default values: It wasn't clear to me why <code>$elems</code> defaulted to 2 (so I removed that default), or whe <code>$overlap</code> defaulted to 1. Wouldn't 0 be a more intuitive default?</p> <p>But my main issue was that the implementation disallowed negative overlaps, and the design docs were silent on the issue. If you visualize how <code>rotor</code> works (take <code>$elems</code> elements from the list, then step back <code>$overlap</code> elements, then rinse and repeat), it's clear what negative overlaps mean: they are steps forward instead of backwards, and create gaps (that is, some list elements aren't included in the sublists).</p> <p>And once you allow negative steps backwards, why not go work with steps forward in the first place, which are more intuitive to the user, and explicitly allow negative steps to create overlaps?</p> <p>So that's what we did, though the end result <a href="http://doc.perl6.org/type/List#method_rotor">is even more general</a>.</p> <p>The crucial question here was <em>why disallow negative overlaps?</em>, or recognizing that a restriction was arbitrary. And then lifting it.</p> <h4>Wording of error messages</h4> <p>Error messages are important to communicate why something went wrong.</p> <p>We used to have the error message <code>Could not find an appropriate parametric role variant for $role</code>. A test for a good error message is: ask <em>why?</em>, and if the piece of code that threw the error can know the answer, the error message needs improving.</p> <p>In this case: why can't the runtime environment find an appropriate variant? Because it didn't try hard enough? No. Because it's buggy? I hope not. It can't find the candidate because it's not there. So, include that answer in the error message: <code>No appropriate parametric role variant available for $role</code>.</p> <p>(Uninformative/lazy error messages are one of my favorite topics for rants; consider the good old <code>SIOCADDRT: No such process</code> that <a href="http://linux.die.net/man/8/route">route(8)</a> sometimes emits, or python's <code>Cannot import name X</code> -- why not? ...)</p> <p>So, write those docs. Write them at a time where you can still change semantics. Keep asking yourself what you could change so the documentation becomes shorter, sweeter, easier understandable.</p> 
<a href="http://strangelyconsistent.org/blog/feed.atom">Strangely Consistent</a> 
 <p>The other day we ran into a bug in the following code in the Perl 6 setting:</p> <pre><code>multi method sign(Real:D:) { self &lt; 0 ?? -1 !! self == 0 ?? 0 !! 1 } </code></pre> <p>Kudos to you if you automatically start poring over the cases in that function, trying to see which one is the wrong one. You won't find it though.</p> <p>The function implements what is more or less the mathematical definition of the <code>sign</code> (or <code>sgn</code>) function:</p> <pre><code> / | -1 if x &lt; 0 | sign(x) = | 0 if x == 0 | | +1 if x &gt; 0 \ </code></pre> <p>The method does exactly this. So what's the problem?</p> <p>Right, <code>NaN</code>.</p> <p>Before the bug was fixed, you'd get this, which is surely wrong:</p> <pre><code>$ perl6 -e 'say sign(NaN)' 1 </code></pre> <p>Oh, and this is what the fixed code looks like:</p> <pre><code>multi method sign(NaN:) { NaN } multi method sign(Real:D:) { self &lt; 0 ?? -1 !! self == 0 ?? 0 !! 1 } </code></pre> <p>(That is, original method remains the same, but a new multi candidate handles the <code>NaN</code>-invocant case.)</p> <p>And now it does the right thing:</p> <pre><code>$ perl6 -e 'say sign(NaN)' NaN </code></pre> <p>I'm trying to come up with an appropriate emotion to go with this kind of bug. It's hard to muster any strong sentiment either way, but I think it's appropriate to say I'm sick of this kind of bug. I wish it were a thing of the past. It feels like it should be a thing of the past.</p> <p>See, the code <em>looks</em> right. It's based right off of the mathematical definition of real numbers. The only slight mistake the original author made was briefly forgetting about the strange numeric value IEEE 754 specifies called "not a number" (<code>NaN</code>), which demands to be taken into account when doing this kind of exhaustive case-matching.</p> <p>Don't get me wrong. <code>NaN</code> is there for a reason, and I'm not clamoring for its removal. The IEEE 754 people certainly had their hearts and their heads in the right place. They got a lot of things right, including the inclusion of <code>NaN</code>. There has to be something that's returned when you take the square root of negative 1, or multiply zero with infinity, or try to find a limit which doesn't exist.</p> <p>No, what frustrates and exhausts me is that <em>it's 2015, and we're still creating bugs rooted in lack of exhaustive case-matching</em>. This should be <em>a solved problem</em> by now. We ought to have moved on to more interesting challenges.</p> <p>And indeed, solutions exist out there. There are linters that will point out when you've left out an important case. (Not for Perl 6, yet, but there's nothing to stop us from having one.) Some languages have case statements over enum types where you're not <em>allowed</em> to leave out a case. Nowadays we also handle things with <code>Maybe</code> or <code>Option</code> types.</p> <p>These things are not even fancy new technology at this point. They're proven to work, and to improve the incidence of thinkos and the quality of code. If we're not equipped with a language (or tooling) that checks this stuff for us, we're part of a rapidly shrinking unfortunate majority. If we're not looking to <em>fix</em> that in our home language, we're increasingly irresponsible and reckless.</p> <p>This is what computing machines are good at! Enumerating cases! We should be having them do that all the time, on our business-critical code. Or, conversely, just writing code without the safety net of full enumeration of cases should be rightly recognized as belonging with other barbaric development practices of the mid-20th century, surely caused by extreme scarcity of memory or CPU, but which we have &mdash; ought to have &mdash; grown out of by now.</p> <p>But... <em>sigh</em>... yes, the code looks right. Which is why I don't particularly feel like running <code>git blame</code> on it this time.</p> <p>Maybe the code snippet was even code-reviewed, and someone had looked at it, nodded, and (at some more or less conscious level) noted that the code aligns perfectly with the mathematical three-case definition. A real number is either smaller than, equal to, or greater than zero. Sure, we know that! This hypothetical code reviewer did not have alarm bells go off just becase the case of <code>NaN</code> wasn't considered. Because <code>NaN</code> is an exception, a fairly uncommon one, and humans enjoy thinking about happy paths.</p> <p>A lot of what constitutes "experience" in a developer seems to be installing these alarm bells in prominent places in one's brain, so that one can write code that's "robust" in the face of unusual values and unhappy paths. Two other such cases spring to mind:</p> <ul> <li><a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">Null pointers/references</a>.</li> <li><a href="http://blogs.perl.org/users/ovid/2013/02/three-value-logic-in-perl.html">NULL values in SQL</a>.</li> </ul> <p>(And indeed, <code>NaN</code> is a kind of "null value" for floating-point numbers.)</p> <p>But it's also about considering edge cases in general. What if the list is empty when we ask for an element? What if the network is unavailable when we try to access a web service? What if the player can exceed 2,147,483,647 points in the game? Things like this <em>can</em>, and <em>should</em> be checked automatically, by the machine, as we developers worry about higher levels of abstraction.</p> <p>Don't settle for less. Let the machine check that we've considered all the cases.</p> 
<a href="http://blog.brentlaabs.com/feeds/posts/default/-/perl6">Irregular Expression</a> 
<br />In the last decade, three major scripting languages embarked on project to produce a major revision to each language: Perl 6, Python 3, and PHP 6. Despite surface similarities, such as the problem of Unicode support, each language ended up on a radically different track.<br /><br />With the Perl 6.0.0 release officially coming this year, it&#39;s a good time to reflect on how we got to this point, and to start thinking about what comes after the release.<br /><br /><h2 id="php-6">PHP 6</h2>So -- and I can&#39;t believe I&#39;m writing this -- let&#39;s see if we can learn something from PHP. Andi Gutmans, who is now the CEO of Zend Technologies, <a href="http://www.itjungle.com/tlb/tlb021208-story09.html">gave an interview</a> back in February 2008. In it, he said, <br /><blockquote>So we are anticipating a long rollout cycle for PHP 6, and we did not want to take the same route that the Perl project did, with project contributors still working on Perl 6 I think six years later. People make fun of Microsoft, but take a look at Perl 6. . . .</blockquote><br />To which Andy Lester of PerlBuzz <a href="https://web.archive.org/web/20140802224335/http://perlbuzz.com/2008/02/tell-us-how-to-do-it-andi.html">replied</a>:<br /><blockquote>Sure, PHP 6 may have a shorter release cycle than Perl 6 has, but at the end of it all, we&#39;ll have Perl 6, and you&#39;ll still have PHP. <br /><br />Just sayin&#39;. <br />xoxo,<br />Andy</blockquote>So how did those predictions work out? Well, after a little over six years of development, we discovered that we were <a href="https://philsturgeon.uk/php/2014/07/23/neverending-muppet-debate-of-php-6-v-php-7/">never going to see a PHP 6 at all</a>. Having seen how long Perl 6 had taken, and how long PHP 6 was taking, the number 6 is associated with failure. So they cancelled PHP 6 and voted to change the name to PHP 7. Problem solved! No, really, this is some of the actual reasoning given by people on the 6 to 7 RFC. (Someone should tell the ES6 folks before the curse strikes our browsers!)<br /><br />But the main intent of the renumbering was to justify a much reduced scope of new features for the next major version of PHP. <a href="http://www.phpclasses.org/blog/post/242-PHP-7-Features-and-Release-Date.html">PHP 7 is slated to add</a>:<br /><ul><li>"Huge Performance Improvements" to the Zend engine (HHVM already pretty speedy)</li><li><strike>JIT to the Zend engine (but already available in HHVM)</strike></li><li>Abstract Syntax Tree (AST) generation</li><li>Asynchronous IO and functions</li><li>Standalone Multi-threading Web Server (HHVM) <ul><li>Which is cool if you want a language to provide its own server, I guess </li></ul></li></ul><b>EDIT</b>: People both here and on <a href="https://news.ycombinator.com/item?id=9484939">Hacker News</a> have pointed out that this is the above feature list was from a bad source, and that much of PHP 6 was incorporated into 5.3.&nbsp; See the <a href="https://blog.engineyard.com/2015/what-to-expect-php-7">better summary of PHP 7 features</a>, including generator improvements, and new operators like <span style="background-color: #eeeeee;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">??</span></span>.&nbsp; However, much of the same analysis still applies -- the end result was very few backwards incompatible changes, not the major revision promised with major Unicode improvements.<br /><br /><h2 id="perl-6">Perl 6</h2>Meanwhile Perl 6, which has taken 15 years to get to the 6.0.0 release slated for <i>this</i> Christmas.&nbsp; I&#39;m sure that there were some embarrassing quotes about when it&#39;s going to be done, but that was so long ago, I&#39;ll just link to <a href="http://blogs.perl.org/users/steven_haryanto/2013/03/dont-wait-for-perl-6-to-build-your-product-on.html">this post forecasting</a> that Perl 6 will be ready for production in 2027.<br /><br />As it now stands, Perl 6 comes with this <a href="http://perl6.org/compilers/features">set of new features</a>:<br /><ul><li>A real type system (not just type hints as in PHP) everywhere <ul><li>The ability to continue ignoring types most short scripting code</li><li>The ability to use static type checks to catch errors</li><li>Native types (C strings, unsigned ints, etc.) unlock new performance potential</li><li>Meta-object programming is available</li></ul></li><li>A sane native function calling interface</li><li>Rakudo Perl 6 runs on multiple virtual machines (JVM, MoarVM), with more backends planned (Javascript) <ul><li>Can compile P6 to bytecode or an AST</li><li>Takes advantage of VM&#39;s JIT</li></ul></li><li>Complete syntax refactoring <ul><li>Fully backwards compatible with the use of Inline::Perl5</li><li>Consistent syntax throughout</li></ul></li><li>Native Unicode handling, with NFG (grapheme) strings by default</li><li>Hygienic macros <ul><li>As I said above, AST</li></ul></li><li>Regexes have evolved to Grammars, a first class language <ul><li>PCRE are no longer Perl-compatible (except in Perl 5 mode), but are instead much easier to read</li></ul></li><li>Easy to use concurrency <ul><li>Some operators will autothread</li><li>Junction types for set operations</li></ul></li><li>Module versioning to ensure that even if a module completely changes its API, your code will not break. If you declare a version, of course.</li></ul>Honestly, there are a whole lot more of these features. This even excludes things that have already made back into the Perl 5 core, like subroutine signatures and smartmatching. And these are all things that are working <i>today</i>.<br /><br />The eerie thing is that Andy&#39;s flippant prediction came true. At the end of it, we have Perl 6, and they still have the same old PHP. Let me repeat that: <i>we have Perl 6</i>. It works, it will get a major release this year, and it is going to come with many more features than originally promised.<br /><br />Still, Perl 6 has had its share of doubters. Some people proposed, actually seriously, that <a href="http://blogs.perl.org/users/ovid/2013/02/perl-7.html">Perl 5 should leapfrog ahead to Perl 7</a> with the next version, and Perl 6 can go on calling itself that if it wants. Right. While this idea was rejected by the general Perl community, PHP actually skipped a version a year later. I guess it&#39;s another example of PHP stealing the worst ideas from Perl.<br /><br /><h2 id="python-3">Python 3</h2>The Python group, on the other hand, has tried to stay mostly on the side of sanity. Python 3 introduced a much smaller set of breaking changes, in order to keep updates rolling out. It was introduced, well, six years ago in early 2009.<br /><br /><a href="https://docs.python.org/release/3.1.2/whatsnew/3.0.html">New features of Python 3</a> included:<br /><ul><li>Sane Unicode handling <ul><li>A breaking change that allowed all of the other breaking changes to happen</li></ul></li><li>Various name changes for style consistency</li><li>Automatically loading C modules when available.</li><li>Refactor of exceptions</li><li>Support for ancient OSes dropped</li><li>Old functions removed, along with generally bad APIs</li><li>Statement form <code>print</code> removed in favor of function <code>print()</code>, ostensibly to make a consistent API <span style="font-size: xx-small;">but really just to mess with people</span>.</li></ul>So how&#39;s that working out? The latest version of python preinstalled on my fully updated MacBook is 2.7.6. At least Ubuntu gives me 3.4.0 â Apple is well known to be crap at updating OSS. But you&#39;d think someone at Apple would have cared in six years would have cared enough to throw python3 in the XCode monster download; after all, Python does not have the <a href="https://news.ycombinator.com/item?id=3559990">kiss of death</a> known as the GPLv3 license.<br /><br />The flip side of availability is developer adoption; this story isn&#39;t much better. If you look at <a href="https://blog.newrelic.com/2014/01/21/python-3-adoption-web-apps/">statistics from a last year</a> and <a href="http://lwn.net/Articles/640181/">this month</a>, Python 3 adoption rates are abysmal. Hell, even 23% of people inside the Python community <a href="https://wiki.python.org/moin/2.x-vs-3.x-survey">still think Python 3 was a mistake</a>. Despite obvious improvements, it&#39;s still considered a tough sell.<br /><br /><h2 id="second-deployment-syndrome">Second Deployment Syndrome</h2>So the takeaway from all of this is that <a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month#The_second-system_effect">Second System Syndrome</a> is a real problem, but not the only problem. Successfully executing major revisions to a language is difficult, but getting widespread <i>adoption</i> is just as difficult with breaking changes. <i>Second Deployment Syndrome</i> can be just as hard to face as making the new system in the first place.<br /><br />So we have three software communities that took radically different approaches to building a second system. PHP is a <a href="http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">complete zoo of awful design</a>, begging to be tamed. Yet the PHP community effectively voted to give up, and only offer incremental change that doesn&#39;t address PHP 6&#39;s number one issue of Unicode support. The Python folks, bless their hearts, made a smaller set of achievable changes, implemented it in 3 years, and shipped the damn thing. And despite the truly useful improvements, only a few people came.<br /><br />Perl decided to stick to its vision of "break all the things once", and it&#39;s taken 15 long years. That&#39;s almost as long as the HTML 5 spec. Over this time, the design has continued to evolve, incorporating more modern needs like easily multithreaded code that would have otherwise been missed. Although the complaint of "no final spec" is common, it has been learned the hard way that the spec is the very last thing that should be finalized.<br /><br />It&#39;s easy to naively say that 15 years is a ridiculous amount of development time, but it&#39;s obvious from looking at second systems for the other scripting languages, Perl 6 was never going to complete such a major transition in less than a decade. What&#39;s still unclear is whether this transition is going to work out for Perl.<br /><br />Nearly everyone who tries Perl 6 from a Perl 5 background likes it immensely, which is usually followed up by a "can this not be so <i>slow</i>?" Optimization is still getting there, just not prematurely. In general, reception has been a net positive. And unlike the breaking changes introduced in the other languages, Inline::Perl5 allows multiple versions of Perl to coexist in the same program.<br /><br />Will this be enough? It&#39;s too early to tell. Perl 5 is going to last another 5 years at the minimum, if not forever, munging text output by a shell script written by a programmer from generations ago. Perl 6 will have an uphill battle with Perl 5 for ubiquity, legacy code, and language familiarity.<br /><br />Adoption rate is the next big challenge facing Perl 6. There is a very real possibility that six years from now, Perl 5 will still be the dominant form of an ever shrinking faction of Perl users. After all, Python might be in the <a href="http://en.wikipedia.org/wiki/TIOBE_index">same boat</a> right now. Perl needs to reverse an already existing downward trend, at least partially brought on by how frakking long Perl 6 took in the first place.<br /><br />The best advice I can see for ensuring Perl 6&#39;s success is for Perl developers to <b>start writing code in Perl 6</b>. I mean now; it&#39;s definitely stable enough. Every module available within a year of release is going to be a major argument for people to try the new version. Getting Shit Done can win a lot of arguments.<br /><br />After that, it&#39;s going to be a tough slog. Is it deployed enough places to distribute code in? Is there enough code written in it to deploy to more places? Package managers like apt and Homebrew are going to help with bootstrapping the user base, but to win Perl 6 going to have to get that killer app.<br /><br />So for now, it&#39;s a giant gamble. In poker terms, Python 3 called, PHP 6 folded, and Perl 6 went all-in. It just might be possible that Perl 6&#39;s crazy long development process can produce the best-adopted second system around, if people decide that the overwhelming improvements are worth the hassle of upgrading.<br /><br />I&#39;ll let you know how that went in six years.
<a href="https://p6weekly.wordpress.com/feed/">Weekly changes in and around Perl 6</a> 
<p>After having gone back a year two weeks ago, this Perl 6 Weekly should bring us back to the present and up to speed.</p>
<h2>Blog Posts</h2>
<p>The past 2 weeks have seen quite some interesting Perl 6 related blog posts:</p>
<ul>
<li><a href="https://6guts.wordpress.com/2015/07/15/this-week-less-than-hoped-but-still-good-stuff/">This Week Less Than Hoped But Still Good Stuff</a> (by <i>Jonathan Worthington</i>)</li>
<li><a href="http://brrt-to-the-future.blogspot.com/2015/07/of-values.html">Of Values</a> (by <i>Bart Wiegmans</i>)</li>
<li><a href="https://6guts.wordpress.com/2015/07/23/this-week-concurrency-stuff-multi-dimensional-stuff-stuff-stuff/">Concurrency Stuff, Multi-Dimensional Stuff, Stuff, Stuff, Stuff</a> (by <i>Jonathan Worthington</i>)</li>
<li><a href="http://blogs.perl.org/users/drforr/2015/07/perltoperl6-released-to-cpan.html">Perl::ToPerl6 Released To CPAN</a> (by <i>Jeffrey Goff</i>)</li>
<li><a href="http://ugexe.com/multiplexing-stdout-from-multiple-processes/">STD multiplexing in Perl6</a> (by <i>Nick Logan</i>)</li>
<li><a href="http://dhaperl6.blogspot.nl">Amongst Butterflies &#8211; And So We Begin</a> (by <i>David Adler</i>)</li>
</ul>
<h2>2015.07.2 Prague</h2>
<p>The past week also saw the monthly compiler release of Rakudo, named &#8220;<a href="https://github.com/rakudo/rakudo/blob/nom/docs/announce/2015.07.md">Prague</a>&#8220;, a joint effort by <i>Carl MÃ¤sak</i> and <i>Moritz Lenz</i>.  It came in at about 350 commits.  There is also a new <a href="http://rakudo.org/2015/07/27/announce-rakudo-star-release-2015-07/">Rakudo Star</a> release (by <i>Moritz Lenz</i>).</p>
<h2>Multi-Lingual Pun Of The Week</h2>
<p><a href="http://irclog.perlgeek.de/perl6/2015-07-23#i_10942545">* cdc veut un racadeau pour NoÃ«l</a>.</p>
<h2>More Asynchronous Sugar</h2>
<p><i>Jonathan Worthington</i> wrote up his thoughts on <a href="https://gist.github.com/jnthn/a56fd4a22e7c43080078">more syntactic sugar and improved semantics for asynchronous execution</a>.  New goodies:</p>
<ul>
<li>await &#8211; more powerful with a dynamic Awaiter</li>
<li>serial supply &#8211; promises you will never do a concurrent emit/done/quit</li>
<li>supply syntax construct &#8211; create on-demand supplies more easily</li>
<li>whenever &#8211; an asynchronous loop construct</li>
<li>Channel &#8211; should probably be renamed for Concurrent::Queue or some such</li>
<li>earliest/more/wait/done to be deprecated</li>
</ul>
<p>Check it out and comment if you want!</p>
<h2>Perl Presence at OSCON 2015</h2>
<p>The past week saw <a href="http://www.oscon.com">OSCON</a> again, for the last time in Portland, OR.  <a href="https://www.flickr.com/photos/wendyga/sets/72157656437146725">Perl&#8217;s presence</a> there was unfortunately limited.  Community booths were smaller again than the year before, and there were fewer of them and they were hidden at the back of the Expo Hall.  In a keynote the lane with community booths was referred to as <a href="https://en.wikipedia.org/wiki/Places_in_Harry_Potter#Diagon_Alley">Diagon Alley</a>.  It would therefore seem that OSCON is becoming more and more a <a href="https://en.wikipedia.org/wiki/Muggle">muggles</a>-only event.  <a href="http://www.oscon.com/open-source-eu-2015">OSCON Europe 2015</a> is said to have no community booths at all.</p>
<p>Anyways, a Perl 6 introductory tutorial by <i>Damian Conway</i>: <a href="http://www.oscon.com/open-source-2015/public/schedule/detail/40630">Perl 6: &#8211; Transparadigm programming 101</a> saved the day in Portland.  It also came with <a href="http://www.bit.do/P6TP">script examples</a>.  The other presentation by <i>Damian Conway</i> was: <a href="http://www.oscon.com/open-source-2015/public/schedule/detail/40632">Don&#8217;t change languages. Change your language</a>.  Here he introduced the very nice Perl 5 module <a href="https://metacpan.org/pod/Dios">Dios</a> Declarative Inside-Out Syntax, which more or less gives you Perl 6 class syntax in Perl 5.  Damian also introduced modules that were more oriented towards Perl 5, such as <a href="https://metacpan.org/pod/experimentals">experimentals</a> and <a href="https://metacpan.org/release/Keyword-Declare">Keyword::Declare</a>.  If you&#8217;re still using Perl 5, they&#8217;re definitely worth looking at.</p>
<h2>Culling from the Backlog</h2>
<ul>
<li><i>Stephane Peyrard</i> opened <a href="https://github.com/perl6/specs/issues/96">an issue about multiple whitespace rules</a></li>
<li><i>Steve Mynott</i> <a href="http://irclog.perlgeek.de/perl6/2015-07-17#i_10914263">mentioned</a> <a href="https://github.com/RichyRich/AntiCat">AntiCat</a> to <i>Timo Paulssen</i></li>
<li><i>Gabor Szabo</i> is <a href="http://perl6maven.com/web-development-using-perl6">preparing</a> his <a href="http://act.yapc.eu/ye2015/talk/6346">Web development using Perl 6</a> presentation at <a href="http://act.yapc.eu/ye2015/">YAPC::EU</a></li>
<li><i>Faye Niemeyer</i> and <i>Geoffrey Broadwell</i> started a <a href="https://gist.github.com/lue/6dfe2fec1579508dde30">Policy Of Decent Behaviour [Draft]</a> which later turned into a <a href="https://github.com/perl6/specs/blob/master/S27-perl-culture-draft.pod6">speculation</a></li>
<li><i>David Adler</i> added a document to his <a href="https://github.com/dha/perl5-to-perl6-docs">Perl 5 to Perl 6 Docs</a> repo that lists <a href="https://github.com/dha/perl5-to-perl6-docs/blob/master/SubjectsForEssentials.txt">the essential changes from Perl 5 to Perl 6 that the typical programmer would need</a></li>
<li><i>H. Merijn Brand</i> pointed out that <a href="https://github.com/Tux/CSV/blob/master/README.speed">Text::CSV</a> had gotten slower again, due to rakudo slowing down</li>
</ul>
<h2>Recent additions to the Ecosystem</h2>
<p>Two weeks worth of additions gives us:</p>
<ul>
<li><a href="https://github.com/jaffa4/inistorage">Ini::Storage</a> Read/write ini files and manipulate them in memory (by <i>jaffa4</i>)</li>
<li><a href="https://github.com/jonathanstowe/Audio-Encode-LameMP3">Audio::Encode::LameMP3</a> Encode PCM Audio data to MP3 in Perl 6 using a binding to liblame (by <i>Jonathan Stowe</i>)</li>
<li><a href="https://github.com/sylvarant/Avro">AVRO support</a> (by <i>Adriaan Larmuseau</i>)</li>
<li><a href="https://github.com/jaffa4/logd">Log::D logging</a> (by <i>jaffa4</i>)</li>
<li><a href="https://github.com/jaffa4/string-stream">Stream::String</a> Stream into a string or from a string (by <i>jaffa4</i>)</li>
<li><a href="https://github.com/azawawi/perl6-atom-electron">Atom::Electron</a> Perl 6 desktop applications using JavaScript, HTML and CSS on top of the Electron platform (by <i>Ahmad M. Zawawi</i>)</li>
<li><a href="https://github.com/jdv/p6-data-selector">Data::Selector</a> data selection dsl parser and applicator (by <i>Justin DeVuyst</i>)</li>
</ul>
<h2>Winding down</h2>
<p>That&#8217;s it for these two weeks again.  Hope to be having the next one on time again.  Have a lot of -OFun!</p><br />  <a rel="nofollow" href="http://feeds.wordpress.com/1.0/gocomments/p6weekly.wordpress.com/602/"><img alt="" border="0" src="http://feeds.wordpress.com/1.0/comments/p6weekly.wordpress.com/602/" /></a> <img alt="" border="0" src="https://pixel.wp.com/b.gif?host=p6weekly.wordpress.com&#038;blog=63973376&#038;post=602&#038;subd=p6weekly&#038;ref=&#038;feed=1" width="1" height="1" />
<a href="http://filip.sergot.pl/en/blog/perl6/index.atom">filip.sergot.pl</a> 
 <p>Hi!</p> <p>At the beginning I want to thank to my mentor, FROGGS, he has done a lot of work during this project, helped and taught a lot.</p> <p>Thanks to moritz as well, he did really great work as the support mentor.</p> <p>There are only three days left, so this post shows the end status of my GSoC project.</p> <h2>The Status</h2> <h3>TLS support (<a href="https://github.com/sergot/openssl">OpenSSL</a>)</h3> <p>Yay, Perl 6 supports TLS now, awesome, it was tested on linux_86-64 machines and works well! It uses OpenSSL, so you must have it installed. </p> <p>This module provides low level bindings to libssl's functions, but it has a higher level class as well, we can use it to handle SSL connection less complicated.</p> <h3><a href="https://github.com/sergot/io-socket-ssl">IO::Socket::SSL</a></h3> <p>I have written a high level module to easily use OpenSSL bindings, it is called IO::Socket:SSL and works just like p6's IO::Socket::INET built-in module.</p> <h3><a href="https://github.com/sergot/http-useragent">HTTP::UserAgent</a></h3> <p>All the HTTP::* modules which are provided by HTTP::UserAgent repo works and does it well. If you want to know more about them just take a look at the documentation in every .pm6 file.</p> <h3>Other modules</h3> <p>To create all this SSL stuff there was a neccessary to write some other modules, not planned at the beginning.</p> <p>Here they are.</p> <p><a href="https://github.com/sergot/datetime-parse">DateTime::Parse</a></p> <p>As the name suggests it is a DateTime parser. So far it parses following datetime formats:</p> <ul> <li>rfc1123</li> <li>rfc850</li> <li>asctime </li> </ul> <p>It was needed to parse datetimes from the header of HTTP messages. Another usage is presented in HTTP::Cookies, where we use it to remove expired cookies.</p> <p><a href="https://github.com/sergot/perl6-encode">Encode</a></p> <p>Decoding only, so far. This project uses it to decode the content of a HTTP message.</p> <h2>The End</h2> <p>Hmm, it is not the end yet! Besides there are three days left, it is not the end because I will continue my work afterwards. :)</p> <p>In the nearest future, I want to test it on other boxes (you can help me here! Would be great) and make it work there (if it wouldn't). The next thing I want to do is to speed it up, optimize, do some cleaning, etc.</p> <p>This project was very interesting, gave me a lot of fun and I learn a lot.</p> <p>Thank you for reading my GSoC posts and I encourage you to visit my blog more often. I want to keep posting. :)</p> 
</body>
</html>

